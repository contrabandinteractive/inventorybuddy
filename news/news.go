package news

import (
  "fmt"
  "net/http"
  "time"
  "strconv"
  "github.com/bold-commerce/go-shopify"
  "net/smtp"
  "os"
  "github.com/twilio/twilio-go"
  "github.com/twilio/twilio-go/rest/api/v2010"
)

var didMessageSend = false

type Article struct {
	Source struct {
		ID   interface{} `json:"id"`
		Name string      `json:"name"`
	} `json:"source"`
	Author      string    `json:"author"`
	Title       string    `json:"title"`
	Description string    `json:"description"`
	URL         string    `json:"url"`
	URLToImage  string    `json:"urlToImage"`
	PublishedAt time.Time `json:"publishedAt"`
	Content     string    `json:"content"`
}


type Results struct {
	TotalResults int
  Status string
  LowTrigger bool
}

type Client struct {
	http     *http.Client
	key      string
	PageSize int
}

type AutoGenerated struct {
	InventoryLevels []struct {
		InventoryItemID   int    `json:"inventory_item_id"`
		LocationID        int    `json:"location_id"`
		Available         int    `json:"available"`
		UpdatedAt         string `json:"updated_at"`
		AdminGraphqlAPIID string `json:"admin_graphql_api_id"`
	} `json:"inventory_levels"`
}


func (c *Client) FetchEverything(query, AccessToken, ShopifyStoreName, VariantID, AlertLevel, EmailAddress, PhoneNumber, page string) (*Results, error) {

  // Get inventory info from Shopify
  // Create an app on Shopify so we can access inventory info
  app := goshopify.App{
    ApiKey: "abcd",
    ApiSecret: "efgh",
    RedirectUrl: "https://example.com/shopify/callback",
    Scope: "read_products",
  }

  // Create a new API client
  client := goshopify.NewClient(app, ShopifyStoreName, AccessToken)

  // Convert Variant ID from string to int64
  intI, err := strconv.ParseInt(VariantID, 10, 64)
  if err != nil {
		return nil, err
	}

  thisVariant, err := client.Variant.Get(intI, nil)


  fmt.Println(int(thisVariant.InventoryQuantity))
  fmt.Printf("%v", thisVariant)


  currentInventoryCount := int(thisVariant.InventoryQuantity)
  AlertLevel2, err := strconv.Atoi(AlertLevel)

  // Determine if inventory is equal to or below warning level
  var StatusMsg string
  var LowTrigger bool
  if currentInventoryCount <= AlertLevel2 {
    StatusMsg = "Warning: inventory needs to be replaced!"
    LowTrigger = true
  }else{
    StatusMsg = "Status: all is good!"
    LowTrigger = false
    //Reset message so it can be set again
    didMessageSend = false
  }


  //Only send notification if it hasn't been sent before AND if stock is low
  if LowTrigger == true && didMessageSend == false {
    fmt.Println("Sending message...")

    // Send email
    from := "inventorybuddy@example.com"

    user := os.Getenv("MAILTRAP_USER")
    password := os.Getenv("MAILTRAP_PASS")

    to := []string{
        EmailAddress,
    }

    addr := "smtp.mailtrap.io:2525"
    host := "smtp.mailtrap.io"

    msg := []byte("From: inventorybuddy@example.com\r\n" +
        "To: " + EmailAddress + "\r\n" +
        "Subject: Low inventory alert\r\n\r\n" +
        "Warning: inventory needs to be replaced!\r\n")

    auth := smtp.PlainAuth("", user, password, host)

    err := smtp.SendMail(addr, auth, from, to, msg)

    if err != nil {
        fmt.Println(err)
    }

    fmt.Println("Email sent successfully")

    // Send SMS
    client := twilio.NewRestClient()

    params := &openapi.CreateMessageParams{}
    params.SetTo(os.Getenv(PhoneNumber))
    params.SetFrom(os.Getenv("TWILIO_PHONE_NUMBER"))
    params.SetBody("Warning: inventory needs to be replaced!")

    _, err := client.ApiV2010.CreateMessage(params)
    if err != nil {
        fmt.Println(err.Error())
    } else {
        fmt.Println("SMS sent successfully!")
    }

    didMessageSend = true
  }

	res := &Results{currentInventoryCount,StatusMsg,LowTrigger}

  return res, nil
}


func NewClient(httpClient *http.Client, key string, pageSize int) *Client {
	if pageSize > 100 {
		pageSize = 100
	}

	return &Client{httpClient, key, pageSize}
}
